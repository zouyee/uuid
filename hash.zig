const std = @import("std");
const crypto = @import("std").crypto;
const UUID = @import("./uuid.zig");

const NameSpaceDNS: UUID = .{ 0x6b, 0xa7, 0xb8, 0x10, 0x9d, 0xad, 0x11, 0xd1, 0x80, 0xb4, 0x00, 0xc0, 0x4f, 0xd4, 0x30, 0xc8 };
const NameSpaceURL: UUID = .{ 0x6b, 0xa7, 0xb8, 0x11, 0x9d, 0xad, 0x11, 0xd1, 0x80, 0xb4, 0x00, 0xc0, 0x4f, 0xd4, 0x30, 0xc8 };
const NameSpaceOID: UUID = .{ 0x6b, 0xa7, 0xb8, 0x12, 0x9d, 0xad, 0x11, 0xd1, 0x80, 0xb4, 0x00, 0xc0, 0x4f, 0xd4, 0x30, 0xc8 };
const NameSpaceX500: UUID = .{ 0x6b, 0xa7, 0xb8, 0x14, 0x9d, 0xad, 0x11, 0xd1, 0x80, 0xb4, 0x00, 0xc0, 0x4f, 0xd4, 0x30, 0xc8 };
const Nil: UUID = .{0};

const Max: UUID = .{ 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF };

/// NewHash creates a UUID from a hash of the given namespace and data.
pub fn NewHash(h: *crypto.hash.Hash, space: UUID, data: []const u8, version: u4) UUID {
    var uuid: UUID = undefined;
    h.init();
    h.update(&space);
    h.update(data);

    const s = h.digest();
    @memcpy(&uuid, &s[0..16]);
    uuid[6] = (uuid[6] & 0x0f) | @as(u8, (version & 0xf) << 4);
    uuid[8] = (uuid[8] & 0x3f) | 0x80; // RFC 4122 variant
    return uuid;
}

/// NewMD5 generates a Version 3 UUID using MD5 based on namespace and data.
pub fn NewMD5(space: UUID, data: []const u8) UUID {
    return NewHash(&crypto.hash.Md5, space, data, 3);
}

/// NewSHA1 generates a Version 5 UUID using SHA1 based on namespace and data.
pub fn NewSHA1(space: UUID, data: []const u8) UUID {
    return NewHash(&crypto.hash.Sha1, space, data, 5);
}
